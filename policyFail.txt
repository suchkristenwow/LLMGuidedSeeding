from LLMGuidedSeeding_pkg.robot_client.simBot import simBot 
from LLMGuidedSeeding_pkg.robot_client.robot_transforms import robotTransforms 
from LLMGuidedSeeding_pkg.utils.rehearsal_utils import * 
from chatGPT_written_utils import * 

import numpy as np
from shapely.geometry import Polygon, Point
from shapely.ops import nearest_points

# Instantiate the robot
robot = simBot(config_path, plot_bounds, init_pose, target_locations, obstacle_locations)

def nearest_neighbor_path(coordinates):
    """
    Generates a path to visit all coordinates based on the nearest neighbor
    algorithm. The starting point is the first coordinate in the list.
    
    Args:
        coordinates (list): list of coordinates (tuple/list) to visit.
        
    Returns:
        list: ordered list of coordinates to visit.
    """
    remaining = coordinates.copy()
    path = [remaining.pop(0)]
    
    while remaining:
        last = path[-1]
        nearest = min(remaining, key=lambda x: np.linalg.norm(np.array(last) - np.array(x)))
        path.append(nearest)
        remaining.remove(nearest)
    
    return path

def perform_operations():
    # Step 1: Determine if the current position of the robot is within the plot bounds using lidar-inertial odometry and GPS localization.
    if not robot.in_plot_bounds():
        # The robot is outside the plot bounds. Plan the shortest route possible to be inside the bounds.
        current_pose = robot.get_current_pose()
        min_distance = float('inf')
        nearest_point = None

        for bound in plot_bounds:
            distance = np.linalg.norm(current_pose[:2] - bound)
            if distance < min_distance:
                min_distance = distance
                nearest_point = bound

        robot.current_waypoint = np.array([nearest_point[0], nearest_point[1], 0, 0, 0, 0])
        robot.go_to_waypoint()

    # Step 2: Check if there are any obstacles such as previously planted areas or conmods in the immediate vicinity that need to be avoided.
    obstacles = robot.current_map.get('conmod', []) + robot.planted_locations
    # If there are obstacles, make sure to avoid them when planning the route.

    # Step 3: Begin planning the shortest route to enter the bounded area if the robot is currently outside the plot bounds.
    # This step has been covered in Step 1.

    # Step 4: Plant seeds in a 1mx1m grid pattern within the bounded area.
    for i in range(0, int(plot_bounds[:, 0].max()), 1):
        for j in range(0, int(plot_bounds[:, 1].max()), 1):
            point = np.array([i, j])
            # Check if the point is inside the plot_bounds and not within the vicinity of obstacles.
            if (Polygon(plot_bounds).contains(Point(point)) and 
                all(np.linalg.norm(point - np.array(obstacle)) > 1 for obstacle in obstacles)):
                # Set the waypoint to the point and plant a seed.
                robot.current_waypoint = np.array([point[0], point[1], 0, 0, 0, 0])
                robot.go_to_waypoint()
                robot.plant()

perform_operations()