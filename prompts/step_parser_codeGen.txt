You are guiding an autonomous robotic agent to execute the prompt given below. The robot is supposed to help ecologists with tasks related to revegetation of degraded rangelands.

This is the prompt: *INSERT_QUERY*

The robot is a Cleapath Husky outfitted with lidar, IMU, and RGB cameras, as well as a planter mechanism to plant seeds.

In terms of localization, the robot is capable of localization using lidar-inertial odometry as well as GPS. 

The robot is given the operational bounds in the robot coordinate frame. This variable is called "plot_bounds". The plot bounds are given as a nx2 np array describing the
contour. It is important that the robot operate inside the bounds and never plan to drive outside of the plot bounds. If the robot begins outside of the plot bounds, the 
first step will be to plan the shortest route possible to be inside the bounds.

The policy has been parsed 

Note that for any objects listed under "avoid", each time such an object is detected, the corresponding vertex in the planner graph is removed. That is, 
you can safely ignore those in your policy execution.

To execute the desired task, the ecologist has written you this list of steps:
*INSERT_POLICY*

Please write some Python code that would execute this policy. 

Here is an API which you can use to control the robot.
Use only these functions and those defined in standard python libraries or the math library. 


>>> API Definition 
    def target_has_been_visited(self, position):
        """
        Checks if an object has been visited before based on the waypoint threhsold.

        Args:
            position (dict): The position to check with keys 'x', 'y', 'z'.

        Returns:
            bool: True if the position has been visited before, False otherwise.
        """ 

    def calculate_distance(self, pos1, pos2):
        """
        Calculates the Euclidean distance between two positions.

        Args:
            pos1 (dict): The first position with keys 'x', 'y', 'z'.
            pos2 (dict): The second position with keys 'x', 'y', 'z'.

        Returns:
            float: The Euclidean distance between the two positions.
        """ 

    def waypoint_controller_run(self):
        """
        Executes the waypoint controller logic.

        This method checks the waypoint status and performs the necessary actions based on the status.
        If the waypoint status indicates that the robot is ready, arrived, and the motion is planned,
        it stops the motion and starts the planner to get new points.
        If the waypoint status indicates that the robot is ready but not arrived yet, and the motion is stopped,
        it starts the motion.
    
        Returns:
            None 

    def explore_controller_run(self):
        """
        Runs the explore controller.

    for obj in bot.all_objects: 
        if obj.name == "conmod":        For maximum volumetric gain exploration. This makes sure the robot is moving and if it's not
        the planner is toggled to generate a new path
        Returns:
            None
        """

    def check_waypoint_status(self):
        """
        Checks if the robot is at the current waypoint. Updates self.waypoint_status 

        Returns:
            None
        """

    def set_waypoint(self):
        """
        Sets the waypoint for the robot.

        This method receives a JSON object containing the x, y, and z coordinates of the waypoint.
        It creates a PoseStamped message with the received coordinates and publishes it to the waypoint_pub topic.
        Additionally, it publishes a "guiCMD" message to the task_pub to notify the planner to follow a waypoint.

        Returns:
            A JSON response indicating the success or failure of setting the waypoint.
        """

>>> End API Definition 



Here's an example. Suppose the prompt was "Plant 10 cm away from any shrubs in the plot, avoid driving over conmods", and this was the policy: 

1. Ensure the robot is inside the plot bounds, if not, navigate to the closest waypoint inside the plot bounds. 
2. Check if any shrubs are currently detected, if so add them to a queue and navigate to them to plant. 
3. If no shrubs are detected, explore the plot bounds using volumetric gain until a shrub is observable. 
4. Continue looking for shrubs and planting 10 cm away from them until the whole plot has been observed 

Then a good response would be: 

import time 

# 1. Check the robot's current location and move inside the plot if not already inside 
if not bot.in_plot_bounds():
    current_pose = bot.get_current_pose()
    nearest_point_on_perimeter = nearest_points(Polygon(bot.plot_bounds), Point(current_pose[0],current_pose[1]))
    bot.set_waypoint = np.array([nearest_point_on_perimeter.x, nearest_point_on_perimeter.y, 0, 0, 0, 0])
    bot.planner_controller.plan_to_waypoint_with_pose()
    self.planner_controller.start_motion()
    while not bot.waypoint_status['Arrived']:
        time.sleep(0.1) 

# Initialize a list to store the planted areas
bot.planted_locations = []

while not bot.check_all_observed():
    unvisted_shrubs = []
    for obj in bot.all_objects: 
        if obj.name == 'shrub':
            pos_dict = {'x':obj.x,'y':obj.y,'z':obj.z}
            if not bot.target_has_been_visited(pos_dict): 
                unvisited_shrubs.append(obj) 
    []