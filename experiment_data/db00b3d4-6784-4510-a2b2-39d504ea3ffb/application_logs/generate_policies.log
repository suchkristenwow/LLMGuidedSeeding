initting the Policy Generator with these arguments:  Namespace(prompt_path='/home/kristen/LLMGuidedSeeding/prompts/ex_query.txt', config_path='/home/kristen/LLMGuidedSeeding/configs/example_config.toml', logging_dir='/home/kristen/LLMGuidedSeeding/experiment_data/db00b3d4-6784-4510-a2b2-39d504ea3ffb/policy_generation_logs', plot_bounds_path='/home/kristen/LLMGuidedSeeding/random_path.csv')
parsing prompt to get constraints ...
prompt:  You are guiding an autonomous robotic agent to execute the prompt given below. The robot is supposed to help ecologists with tasks related to revegetation of degraded 
rangelands.

The robot is able to observe landmarks via RGB cameras and it is able to plant seeds. 

Given the following prompt, identify any relevant constraints or goal landmarks in the form of a dictionary so that I can write a policy to execute the desired task. 

The keys to this dictionary should be the strings "avoid","goal_lms","pattern","landmark_offset","search", "seed", and "pattern_offset". Here, seed is a string of a boolean variable 
which is true if the robot should plant in the specified pattern. 

For example, if the prompt was: "Plant 10 cm away from any shrubs in the plot", return {"goal_lms":"shrub","landmark_offset":0.1,"seed":"True"}. Or, if the prompt was 
"Seed along the fenceline in a straight row, 15 cm apart", return {"goal_lms":"fence","pattern_offset":0.15,"pattern":"line","seed":"True"}. 
Finally, the prompt: "Count how many shrubs are in the plot." would return {"search":"shrubs","seed":"False"}.

If you're not sure how to format the constraints into this dictionary format, return a question in the form of a string that would help allow you to parse the prompt 
into the dictionary format. An example of a follow-up question could be "I'm sorry, I'm not sure how to parse your prompt. Currently, I want to format the constraints of 
your prompt into a dictionary with the keys: "avoid","goal_lms","pattern","landmark_offset","search", and "pattern_offset". Do you think your prompt constraints can be categorized 
like this or should I edit my constraint dictionary format?"

Prompt: Plant in 1mx1m grid in the bounded area. Avoid driving over wherever you’ve planted or any conmods.

Trying to get response ...
response.status_code:  200
llm_result: {"avoid":"planted areas, conmods", "pattern":"grid", "pattern_offset":1, "seed":"True"}
results_str:  {"avoid":"planted areas, conmods", "pattern":"grid", "pattern_offset":1, "seed":"True"}
constraints:  {'avoid': 'planted areas, conmods', 'pattern': 'grid', 'pattern_offset': 1, 'seed': True}
building policy...
feedback is none!
constraints[k]:  planted areas, conmods
<class 'str'>
split_constraint:  ['planted areas', ' conmods']
this is  a list!
constraints[k]:  grid
<class 'str'>
constraints[k]:  1
<class 'int'>
constraints[k]:  True
<class 'bool'>
extending prompt lms
prompt lms:  ['planted areas', ' conmods']
I dont know what planted areas is. Ill have to ask.
I dont know what  conmods is. Ill have to ask.
using enhanced prompt to generate a policy
prompt:  You are guiding an autonomous robotic agent to execute the prompt given below. The robot is supposed to help ecologists with tasks related to revegetation of degraded rangelands.

The robot is able to observe landmarks via RGB cameras and it is able to plant seeds. The robot is capable of localization using lidar-inertial odometry as well as GPS. 
Whenever there is some uncertainty, you can interface with the human for more direction or context. 

The robot is given the operational bounds in the robot coordinate frame. This variable is called "plot_bounds". The plot bounds are given as a nx2 np array describing the
contour. It is important that the robot operate inside the bounds and never plan to drive outside of the plot bounds. If the robot begins outside of the plot bounds, the 
first step should be to plan the shortest route possible to be inside the bounds.

In addition to a user-given prompt, I also have a dictionary of important constraints. 

The entry under the key "avoid" is a list of objects the user wishes the robot to avoid. The entry under the key "goal_lms" are objects the user wishes the robot to find 
and navigate towards. The entry under "pattern" is a string defining the desired pattern in which the robot should drive to execute the task. The entry under "seed" is 
a boolean variable indicating if the user wants the robot to seed as part of the policy or not. Finally, the entry under "pattern_offset" is a float variable indicating 
any relevant offset to completing the task. For example if the user says "Plant 10 cm away from any shrubs in the plot", the "pattern_offset" would be 0.1. 

For example, if the prompt was: "Plant 10 cm away from any shrubs in the plot", the constraint dictionary would be {"goal_lms":"shrub","landmark_offset":0.1,"seed":"True"}. 
Or, if the prompt was "Seed along the fenceline in a straight row, 15 cm apart", the constraint dicrionary would be  {"goal_lms":"fence","pattern_offset":0.15,"pattern":"line","seed":"True"}. 
Finally, the prompt: "Count how many shrubs are in the plot." would have the constraint dictionary {"search":"shrubs","seed":"False"}.

Given the following prompt and the constraint dictionary, write a step by step policy which would accomplish the given task. Enumerate each of the steps like 1. Do foo, 2. Look for bar ...

If there is a landmark in the "goal_lms" which you can't locate in the immediate environment, tell the user "I can't find {landmark}, where should I look?"

If the "plant" boolean is True, be sure to maintain a list in the system memory of all the planted locations.

You can assume that the robot is on, and the plot bounds and constraints are already loaded into the system memory. 

Be sure to give your response in the form of a numbered list so I can easily parse your response.

constraint_dictionary: {'avoid': ['planted areas', ' conmods'], 'pattern': 'grid', 'pattern_offset': 1, 'seed': True}

Prompt: Plant in 1mx1m grid in the bounded area. Avoid driving over wherever you’ve planted or any conmods.

Trying to get response ...
response.status_code:  200
policy:  None
